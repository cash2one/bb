#!/usr/bin/env python3

dummy_send = lambda x: print(x)

def http():
    """TODO"""

def websocket(staffs, tokens, send=dummy_send):
    import logging

    from tornado.websocket import WebSocketHandler

    from .const import NULL, ONLINE

    class WebSocket(WebSocketHandler):
        def open(self):
            print(id(self))

        def on_close(self):
            i = self.i
            send([i, ONLINE, NULL])
            staffs.pop(i, i)  # :(
            logging.info("%s %s logout", "ws", i)

        def on_message(self, message):
            logging.debug("ws message: %r", message)
            i, msg = message.split(None, 1)
            i = int(i)
            try:
                send([self.i, i, msg or NULL])
            except AttributeError:  # if has no attribute `i`, login it
                self.login(i, msg)

        def login(self, i, k):
            assert isinstance(i, int), i
            assert isinstance(k, str), k
            try:
                t = tokens.pop(i)
                if k != t:
                    raise Warning("token error: {!r} != {!r}".format(k, t))
                if i in staffs:
                    staffs.pop(i).logout()
                self.i = i
                staffs[i] = self
                logging.info("%s %s login", "ws", i)
            except Exception as e:
                self.close()
                logging.error("failed to auth: %s: %s", type(e).__name__, e)

        def send(self, cmd, data):
            self.write_message(str(cmd) + " " + data)

        def logout(self):
            self.close()
            self.on_close()

    return WebSocket


def tcp(staffs, tokens, send=dummy_send):
    import logging
    import re
    import struct
    from tornado.tcpserver import TCPServer
    from .const import STRUCT, NULL, ONLINE
    from .dbg import show

    head_match = re.compile(r'.*(\d+) (\w+)\r\n\r\n$', re.S).match
    _struct = struct.Struct(STRUCT)
    pack, unpack = _struct.pack, _struct.unpack

    class Connection(object):
        def __init__(self, stream, address):
            self.stream = stream
            self.address = address
            self.stream.read_until(b'\r\n\r\n', self.login)
            logging.info("%s try in", self.address)

        def login(self, auth):
            """format: .* id token\r\n\r\n
            token can be generated by visit /token?1.key
            """
            stream = self.stream
            try:
                auth = auth.decode()
                i, k = head_match(auth).groups()
                i = int(i)
                t = tokens.pop(i)
                if k != t:
                    raise Warning("token error: {!r} != {!r}".format(k, t))
                if i in staffs:
                    staffs.pop(i).logout()
                self.i = i
                stream.set_close_callback(self.logout)
                stream.read_bytes(4, self.msg_head)
                staffs[i] = self
                logging.info("%s %s login", self.address, i)
            except Exception as e:
                stream.close()
                logging.error("failed to auth: {}({}) {!r}".format(
                    type(e).__name__, e, auth))

        def send(self, cmd, data):
            stream = self.stream
            if not stream.closed():
                stream.write(pack(len(data) + 2, cmd) + data)

        def logout(self):
            stream = self.stream
            if stream.closed():
                i = self.i
                send([i, ONLINE, NULL])
                logging.info("%s %s logout", self.address, i)
            else:
                stream.close()

        def msg_head(self, chunk):
            stream = self.stream
            #show(chunk)
            packet_size, instruction = unpack(chunk)
            #show(packet_size, instruction)
            self.instruction = instruction
            if not stream.closed():
                stream.read_bytes(packet_size - 2, self.msg_body)

        def msg_body(self, chunk):
            stream = self.stream
            #show(chunk)
            send([self.i, self.instruction, chunk or NULL])
            if not stream.closed():
                stream.read_bytes(4, self.msg_head)

    class Server(TCPServer):
        def handle_stream(self, stream, address):
            Connection(stream, address)

    return Server


def backdoor(coroutine):
    import logging
    from tornado.tcpserver import TCPServer
    from time import strftime
    from .const import TIME_FORMAT
    welcome = (strftime(TIME_FORMAT) + "\n{}\n>>> ").format
    fmt_log_input = "shell input: {!r}".format
    fmt_log_output = "shell output: {!r}".format

    class Connection(object):
        def __init__(self, stream, address):
            stream.set_close_callback(stream.close)
            stream.write(welcome(strftime(TIME_FORMAT)).encode())
            stream.read_until(b'\n', self.handle_input)
            self.stream = stream

        @coroutine
        def handle_input(self, line):
            source = line.decode()
            stream = self.stream
            logging.info(fmt_log_input(source))
            stream.read_until(b'\n', self.handle_input)
            result = yield "shell", source
            logging.info(fmt_log_output(result))
            stream.write(result.encode())

    class Server(TCPServer):
        def handle_stream(self, stream, address):
            Connection(stream, address)

    return Server
