#!/usr/bin/env python3

def http():
    """TODO"""

def websocket(Q0, tokens, staffs):
    import logging

    from tornado.websocket import WebSocketHandler

    from bb.const import NULL, ONLINE

    class WebSocket(WebSocketHandler):
        def open(self):
            print(id(self))

        def on_close(self):
            i = self.i
            Q0.put([i, ONLINE, NULL])
            logging.info("%s %s logout", "ws", i)
            if staffs.get(i) is self:  # have to do it (without gc enable)
                staffs.pop(i)

        def on_message(self, message):
            logging.debug("ws message: %r", message)
            i, msg = message.split(None, 1)
            i = int(i)
            try:
                Q0.put([self.i, i, msg or NULL])
            except AttributeError:  # if has no attribute `i`, login it
                try:
                    k = msg
                    t = tokens.pop(i)
                    if k != t:
                        raise Warning("error token: %s != %s" % (k, t))
                    self.i = i
                    if i in staffs:
                        staffs[i].close()
                        Q0.put([i, ONLINE, NULL])
                        logging.info("ws kick %s", i)
                    staffs[i] = self
                    logging.info("%s %s login", "ws", i)
                except Exception as e:
                    self.close()
                    logging.error("failed to auth: %s: %s", type(e).__name__, e)
    return WebSocket


def tcp(Q0, tokens, staffs):

    import logging
    from struct import pack, unpack

    from tornado.tcpserver import TCPServer

    from bb.const import FMT, NULL, ONLINE

    class Connection(object):
        def __init__(self, stream, address):
            self.stream = stream
            self.address = address
            self.stream.read_until(b'\n', self.login)
            logging.info("%s try in", address)

        def login(self, auth):
            """format: id token\n
            token can be generated by visit //bb/t?it=1&it=token
            """
            try:
                i, k = auth.split()
                i = int(i)
                k = k.decode()
                t = tokens.pop(i)
                if k != t:
                    raise Warning("error token: %s != %s" % (k, t))
                self.i = i
                if i in staffs:
                    staffs[i].close()
                    Q0.put([i, ONLINE, NULL])
                    logging.info("tcp kick %s", i)
                staffs[i] = self.stream
                self.stream.set_close_callback(self.logout)
                self.stream.read_bytes(4, self.msg_head)
                logging.info("%s %s login", self.address, i)
            except Exception as e:
                self.stream.close()
                logging.error("failed to auth: %s: %s", type(e).__name__, e)

        def msg_head(self, chunk):
            logging.debug("head: %s", chunk)
            instruction, length_of_body = unpack(FMT, chunk)
            logging.debug("%d, %d", instruction, length_of_body)
            self.instruction = instruction
            if not self.stream.closed():
                self.stream.read_bytes(length_of_body, self.msg_body)

        def msg_body(self, chunk):
            logging.debug("body: %s", chunk)
            Q0.put([self.i, self.instruction, chunk.decode() or NULL])
            if not self.stream.closed():
                self.stream.read_bytes(4, self.msg_head)

        def logout(self):
            self.stream.close()
            Q0.put([self.i, ONLINE, NULL])  # see inst.py, "online" is 101
            logging.info("%s %s logout", self.address, self.i)


    class Server(TCPServer):
        def handle_stream(self, stream, address):
            Connection(stream, address)

    return Server


def backdoor(Q0, wheels):
    from tornado.tcpserver import TCPServer
    class Connection(object):
        def __init__(self, stream, address):
            self.stream = stream
            wheels[address] = stream
            self.stream.set_close_callback(self.stream.close)
            self.stream.write(b"Backdoor\n>>> ")
            self.stream.read_until(b'\n', self.handle_input)

        def handle_input(self, line):
            Q0.put(["shell", line.decode()])
            self.stream.read_until(b'\n', self.handle_input)

    class Server(TCPServer):
        def handle_stream(self, stream, address):
            Connection(stream, address)

    return Server
